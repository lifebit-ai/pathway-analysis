---
title: "Differential expression analysis with Kallisto and DEseq2"
output:
  html_document:
    df_print: paged
params:
  annotation: "annotation_file"
  condition: "condition"
  hallmark: "hallmark_file"
  kegg: "kegg_file"
  mir: "mir_file"
  go: "go_file"
---

## Using DESeq2 with kallisto abundances files

This R Markdown takes 3 inputs:

1. The **abundances** TSV files. This can be generated from **`kallisto`**.
2. The **annotation** file containing the samples and their associated metadata, like each condition
3. The **condition** of interest for example one condition we might want to analyse is simply the treatment used on the samples

```{r}
params$annotation
params$condition
```

## Preprocessing

### 1. Loading the abundances

We will be loading the abundances files:

```{r}
sample_ids <- dir(file.path('kallisto'))
sample_ids <- sub("^kallisto_", "", sample_ids)
abundances <- file.path('kallisto', paste0('kallisto_', sample_ids), 'abundance.h5')
abundances
```

### 2. Loading the annotation
Then will have to load the information for the annotation. And make the read count matrix names match the ones in the sample table.

```{r}
# Load sample table with metadata
sampleTable <- read.csv(params$annotation, row.names = 1)
```

We are going to make sure we analyse the exactly same samples we have between sample table and abundances data.

```{r}
sample_ids
sampleTable
```

### 3. Setting the condition of interest

Here we select/extract the one condition we want to analyse, eg the treatment was used on each sample:

```{r}
condition <- unlist(sampleTable[params$condition])
condition
```

## Differential Expression Analysis

Now that we have prepared the sample and abundances, we can load the libraries including the DEseq2 to perform Differential Expression analysis.

```{r}
suppressMessages({
  library(biomaRt)
  library(DESeq2)
  library(dplyr)
  library(tximport)
})
```

Firstm we'll load the gene info

```{r}
mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_ENSEMBL",
  dataset = "hsapiens_gene_ensembl",
  host = "may2015.archive.ensembl.org")
ttg <- biomaRt::getBM(
  attributes = c("ensembl_transcript_id", "transcript_version",
  "ensembl_gene_id", "external_gene_name", "description",
  "transcript_biotype"),
  mart = mart)
ttg <- dplyr::select(ttg, TXNAME = ensembl_transcript_id,
  GENEID = ensembl_gene_id)
head(ttg)
```


Next, we create the DEseq dataset object using the abundances and the sample data.

```{r}
txi_kallisto <- tximport(abundances, type='kallisto', tx2gene=ttg)
dds <- DESeqDataSetFromTximport(txi=txi_kallisto, colData=sampleTable, design= as.formula(paste("~", params$condition)))
dds
```

Then we can run the Differential Expression pipeline with just the command:

```{r}
dds <- DESeq(dds)
```

### Dispersion plot

We can have a look at the dispersion of read counts across genes in all samples

```{r}
plotDispEsts(dds, main="Dispersion plot")
```

### Log Transformation & Histogram

We will then apply log transformation to the read counts and will try to cluster the samples according the log transform counts

```{r}
# Regularized log transformation for clustering/heatmaps, etc
rld <- rlogTransformation(dds)
head(assay(rld))
hist(assay(rld))
```

### Sample Distance Matrix
```{r}
suppressMessages(library(RColorBrewer))
(mycols <- brewer.pal(8, "Dark2")[1:length(unique(condition))])

sampleDists <- as.matrix(dist(t(assay(rld))))
```

By calculating distances across samples from log transformed counts we can plot the distance matrix and colour the samples according to the condition.

```{r}
suppressMessages(library(gplots))
heatmap.2(as.matrix(sampleDists), key=F, trace="none",
          col=colorpanel(100, "black", "white"),
          ColSideColors=mycols[condition], RowSideColors=mycols[condition],
          margin=c(10, 10), main="Sample Distance Matrix")
```

### PCA Biplot
```{r}
rld_pca <- function (rld, intgroup = "condition", ntop = 500, colors=NULL, legendpos="bottomleft", main="PCA Biplot", textcx=1, ...) {
  require(genefilter)
  require(calibrate)
  require(RColorBrewer)
  rv = rowVars(assay(rld))
  select = order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca = prcomp(t(assay(rld)[select, ]))
  fac = factor(apply(as.data.frame(colData(rld)[, intgroup, drop = FALSE]), 1, paste, collapse = " : "))
  if (is.null(colors)) {
    if (nlevels(fac) >= 3) {
      colors = brewer.pal(nlevels(fac), "Paired")
    }   else {
      colors = c("black", "red")
    }
  }
  pc1var <- round(summary(pca)$importance[2,1]*100, digits=1)
  pc2var <- round(summary(pca)$importance[2,2]*100, digits=1)
  pc1lab <- paste0("PC1 (",as.character(pc1var),"%)")
  pc2lab <- paste0("PC1 (",as.character(pc2var),"%)")
  plot(PC2~PC1, data=as.data.frame(pca$x), bg=colors[fac], pch=21, xlab=pc1lab, ylab=pc2lab, main=main, ...)
  with(as.data.frame(pca$x), textxy(PC1, PC2, labs=rownames(as.data.frame(pca$x)), cex=textcx))
  legend(legendpos, legend=levels(fac), col=colors, pch=20)
}

```

We can easily use a PCA visualization to see how the variation separates samples, but also how mixed

```{r}
suppressMessages(rld_pca(rld, colors=mycols, intgroup=params$condition, xlim=c(-75, 35)))
```

### Results table of top genes by adjusted p-value

On last steps, we want to be able to filter and to extract genes based on certain thresholds. We can apply filter in order to filter for p-values and adjusted p-values on top of the results table.

```{r}
res <- results(dds)
table(res$padj<0.05)

## Order by adjusted p-value
res <- res[order(res$padj), ]

## Merge with normalized count data
resdata <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=TRUE)), by="row.names", sort=FALSE)
names(resdata)[1] <- "Gene"
head(resdata)
## Write results
write.csv(resdata, file="diffexpr-results.csv")
```

### Histogram of p-value

There are also several plots available for quality control on top of the results we got that we can explore, like the histogram of significance levels.

```{r}
hist(res$pvalue, breaks=50, col="grey")
```

### MA Plot

```{r}
maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=1, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
  }
}
```

Also the MA plot, where we can see how the log fold changes compare against the mean averages across genes

```{r}
maplot(resdata, main="MA Plot")
```

### Volcano plot

The last plot we show is the volcano plot, where we can visualize what's the relationship between log fold changes and significance levels in our test.

```{r}
volcanoplot <- function (res, lfcthresh=2, sigthresh=0.05, main="Volcano Plot", legendpos="bottomright", labelsig=TRUE, textcx=1, ...) {
  with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
  with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
  with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
  with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="green", ...))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=textcx, ...))
  }
  legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","green"))
}
```

```{r}
volcanoplot(resdata, lfcthresh=2, sigthresh=0.01, textcx=.8, xlim=c(-2.3, 2))
```

## FGSEA on DESeq results

Load the required libraries:

```{r}
suppressMessages({
  library(org.Hs.eg.db)
  library(fgsea)
  library(tidyverse)
})
```

Load and save the DESeq2 results

```{r}
res <- results(dds, tidy = TRUE)
res
readr::write_csv(res, path="deseq-results-tidy.csv")
```

Map Ensembl gene IDs to symbol. First create a mapping table.

```{r}
ens2symbol <- AnnotationDbi::select(org.Hs.eg.db,
                                    key=res$row, 
                                    columns="SYMBOL",
                                    keytype="ENSEMBL")
ens2symbol <- as_tibble(ens2symbol)
ens2symbol
```

Now join them.

```{r}
res <- inner_join(res, ens2symbol, by=c("row"="ENSEMBL"))
res
```

Further, all you’ll care about later on is the gene symbol and the test statistic. Get just those, and remove the NAs. Finally, if you have multiple test statistics for the same symbol, you’ll want to deal with that in some way. Here I’m just averaging them.
```{r}
res2 <- res %>% 
  dplyr::select(SYMBOL, stat) %>% 
  na.omit() %>% 
  distinct() %>% 
  group_by(SYMBOL) %>% 
  summarize(stat=mean(stat))
res2
```

### Using the fgsea package

We're going to use the [fgsea package](http://bioconductor.org/packages/fgsea) for fast preranked gene set enrichment analysis (GSEA). See the [preprint](https://www.biorxiv.org/content/early/2016/06/20/060012) for more details. From the abstract:

> Gene set enrichment analysis is a widely used tool for analyzing gene expression data. However, current implementations are slow due to a large number of required samples for the analysis to have a good statistical power. In this paper we present a novel algorithm, that efficiently reuses one sample multiple times and thus speeds up the analysis. We show that it is possible to make hundreds of thousands permutations in a few minutes, which leads to very accurate p-values. This, in turn, allows applying standard FDR correction procedures, which are more accurate than the ones currently used. 

The `fgsea()` function requires a list of gene sets to check, and a named vector of gene-level statistics, where the names should be the same as the gene names in the pathways list. First, let's create our named vector of test statistics. See `?tibble::deframe` for help here - `deframe()` converts two-column data frames to a named vector or list, using the first column as name and the second column as value.

```{r}
ranks <- deframe(res2)
head(ranks, 20)
```


Let's use the [Hallmark gene set](http://software.broadinstitute.org/gsea/msigdb/collection_details.jsp#H) from MSigDB. Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying overlaps between gene sets in other MSigDB collections and retaining genes that display coordinate expression. The `gmtPathways()` function will take a GMT file you [downloaded from MSigDB](http://software.broadinstitute.org/gsea/downloads.jsp) and turn it into a list. Each element in the list is a character vector of genes in the pathway.

```{r}
# Load the pathways into a named list
pathways.hallmark <- gmtPathways(params$hallmark)
# Look at them all if you want (uncomment)
# pathways.hallmark
# Show the first few pathways, and within those, show only the first few genes. 
pathways.hallmark %>% 
  head() %>% 
  lapply(head)
```

# Now, run the fgsea algorithm with 1000 permutations:

# ```{r}
# fgseaRes <- fgsea(pathways=pathways.hallmark, stats=ranks, nperm=1000)
# ```

# Tidy the results:

# ```{r}
# fgseaResTidy <- fgseaRes %>%
#   as_tibble() %>%
#   arrange(desc(NES))
# # Show in a nice table:
# fgseaResTidy %>% 
#   dplyr::select(-leadingEdge, -ES, -nMoreExtreme) %>% 
#   arrange(padj) %>% 
#   DT::datatable()
# ```

# Plot the normalized enrichment scores. Color the bar indicating whether or not the pathway was significant:

# ```{r}
# ggplot(fgseaResTidy, aes(reorder(pathway, NES), NES)) +
#   geom_col(aes(fill=padj<0.05)) +
#   coord_flip() +
#   labs(x="Pathway", y="Normalized Enrichment Score",
#        title="Hallmark pathways NES from GSEA") + 
#   theme_minimal()
# ```

# What genes are in each of these pathways? First, get a tibble with all the pathways and the genes in them. Continue to join that back to the original data to pull out genes in the pathways. Optionally, filter the list to include only those that are significant, etc. 

# ```{r}
# pathways.hallmark %>% 
#   enframe("pathway", "SYMBOL") %>% 
#   unnest() %>% 
#   inner_join(res, by="SYMBOL")
# ```

# Let's try a different set of pathways. Let's look at KEGG pathways:

# ```{r}
# fgsea(pathways=gmtPathways(params$kegg), ranks, nperm=1000) %>% 
#   as_tibble() %>% 
#   arrange(padj)
# ```

# Or miR targets:

# ```{r}
# fgsea(pathways=gmtPathways(params$mir), ranks, nperm=1000) %>% 
#   as_tibble() %>% 
#   arrange(padj)
# ```

# Or GO annotations: 

# ```{r}
# fgsea(pathways=gmtPathways(params$go), ranks, nperm=1000) %>% 
#   as_tibble() %>% 
#   arrange(padj)
# ```